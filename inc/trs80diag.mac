; simulate bit errors in these modules
SIMERROR_RND defl 0
SIMERROR_MARCH defl 0
SILENCE defl 0

dbz macro string
	db "`string`", 0
endm

;
; iycall: make a "call" without using the stack.  Something like ARM branch and link.
iycall macro subroutine
		ld iy,$+7
		jp subroutine
endm

iyret macro
		jp (iy)
endm


haltcpu macro
		jr $
endm


music macro tune
		; ld ix, tune
		ld hl,tune
		iycall playmusic
endm



; pause macro destroys a,b,c regs!
pause macro count
	local loop
		ld bc,count
	.`loop:
		dec bc
		ld a,b
		or c
		jnz .`loop

endm






link_memtest_block_announce macro membase, memsize, memname
		mac_con_NL
		mac_con_print memname
		ld hl,membase
		ld bc,memsize
		call announcetest
endm

link_memtest_block macro membase, memsize, memname
		link_memtest_block_announce membase, memsize, memname
		ld e,0
		link_memtest memtestmarch, membase, memsize
endm


link_memtest macro proc, base, size
	local branch
		ld iy,.`branch
		jp proc

		; db value
		dw base, size
	.`branch:
endm

; link_memtest_stack macro proc, base, size, value
; 		push ix
; 		link_memtest proc, base, size, value
; 		pop ix
; endm

link_loadregs macro
		ld b,(iy-1)
		ld c,(iy-2)
		ld h,(iy-3)
		ld l,(iy-4)
endm

; link_loadregs_all macro
; 		link_loadregs
; 		ld a,(iy-5)
; endm

mac_soundbiterr macro bitnum
	local zero,cont
		pause $4000

		bit bitnum,e
		jp z,.`zero

		music bitbadnotes
		jp .`cont
	.`zero:
		music bitgoodnotes
	.`cont:
endm

play_bit_errors macro
	local allbad, pbe_done
		ld a,$FF
		cp e
		jp z,.`allbad

		irpc bn,76543210
			mac_soundbiterr bn
		endm
		jr .`pbe_done
	.`allbad:
		music bytebadnotes
	.`pbe_done:
endm

mac_soundbiterrs macro
	local showbit, zero, msbe_cont
		ld b,8
	.`showbit:
		bit 7,e
		jr z,.`zero
		ld hl,bitbadnotes
		jr .`msbe_cont
	.`zero:
		ld hl,bitgoodnotes
	.`msbe_cont:
		iycall playmusic
		dec a
		rlc e
		djnz .`showbit
endm


mac_reportmem macro
	local bad, ok, cont
		jp nc,.`ok

		mac_con_print_iy biterrmsg
		iycall printbiterr_iy
		mac_con_clear_eol
		play_bit_errors
		jp .`cont
	.`ok:
		mac_con_print_iy okmsg
		mac_con_clear_eol
		music bytegoodnotes
	.`cont:
endm

mac_reportmem_stackbank_bad macro
		mac_con_print_iy biterrmsg
		iycall printbiterr_iy
		mac_con_print_iy haltmsg
		mac_con_clear_eol
		play_bit_errors
		haltcpu
endm

mac_reportmem_stackbank_ok macro
		mac_con_print_iy okmsg
		mac_con_print_iy msgstack
		mac_con_clear_eol
		music bytegoodnotes
endm

mac_reportmem_stackbank macro
	local bad, mrs_ok
		jp nc,.`mrs_ok
		mac_reportmem_stackbank_bad
	.`mrs_ok:
		mac_reportmem_stackbank_ok
endm



; console macros
; global reg:
;	ix = pointer to current location in screen memory
; destroy:
;	a = working reg
;	hl = working pointer (and incoming parameter)
;	bc = counter
; preserve:
;	de
;	iy

mac_con_home macro
		ld ix,VBASE
endm

mac_con_clear macro
	local loop
		ld ix,VBASE
		ld bc,VSIZE
	.`loop:
		ld (ix+0),20h
		inc ix
		cpi
		jp pe,.`loop

		ld ix,VBASE
endm

mac_con_printc macro
		ld (ix+0), a
		inc ix
endm

mac_itoh_nybble macro
		or $F0
		daa			; is lower nybble >9? (as if doing BCD math)
		add a, $A0
		adc a, $40		; >9, so move up to 'A'
endm

mac_con_printx macro
		ld b,a			; save a copy of the number to convert
		rra			; get upper nybble
		rra
		rra
		rra
		mac_itoh_nybble		; convert to ascii
		mac_con_printc
		ld a,b			; fetch lower nybble
		mac_itoh_nybble		; convert to ascii
		mac_con_printc		
endm

mac_con_CR macro
		ld a,ixl
		and $c0
		ld ixl,a
endm

mac_con_col macro
		ld b,0
		ld c,a
		mac_con_CR
		add ix,bc
endm

mac_con_index macro moveby
		ld bc,moveby
		add ix,bc
endm

mac_con_NL macro
	local skip
		; ld b,0
		; ld c,$40
		; mac_con_CR
		; add ix,bc
		ld a,ixl		; go to beginning of line
		and $c0			; then go to the next line
		add a,$40
		ld ixl,a		; store the low byte back
		jr nc,.`skip
		inc ixh			; fix up high byte if there was a carry
	.`skip:
endm

mac_con_row macro row
		ld ix,VBASE+(row*VLINE)     ; add this offset to the base
endm

mac_con_println macro message
		ld hl,message
		call con_println
endm

mac_con_print_nostack macro message
	local loop,done
		ld hl,message
	.`loop:
		ld a,(HL)       ; get message char
		or a            ; test for null
		jr z, .`done     ; return if done
		ld (ix+0),A     ; store char
		inc ix          ; advance screen pointer
		inc hl          ; advance message pointer
		jr .`loop        ; continue
	.`done:
endm


mac_con_print macro message
		ld hl,message
		call con_print
endm

mac_con_print_iy macro message
		ld hl,message
		iycall con_print_iy
endm

mac_con_clear_eol macro
	local loop
		ld a,ixh
		ld h,a
		ld a,ixl
		ld l,a
		
	.`loop:
		ld a,' '
		mac_con_printc
		ld a,ixl
		and $3F			; see if we are at the beginning of the line
		jr z,.`loop

		ld a,h
		ld ixh,a
		ld a,l
		ld ixl,a
endm