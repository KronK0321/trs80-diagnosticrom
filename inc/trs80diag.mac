	.list -1
	.mlist -1

; simulate bit errors in these modules
SIMERROR_RND defl 0
SIMERROR_MARCH defl 0
SILENCE defl 0

JP_ERROR defl 0
JR_PROMOTE defl 0

	.jperror JP_ERROR
	.jrpromote JR_PROMOTE

dbz .macro string
	db "`string`", 0
.endm

;
; iycall: make a "call" without using the stack.  Something like ARM branch and link.
iycall .macro subroutine
		ld iy,$+7
		.jperror 0
		jp subroutine
		.jperror JP_ERROR
.endm

iyret .macro
		jp (iy)
.endm


haltcpu .macro
		jr $
.endm


music .macro tune
		; ld ix, tune
		ld hl,tune
		iycall playmusic
.endm



; pause macro destroys a,b,c regs!
pause .macro count
	.local loop
		ld bc,count
	.`loop:
		dec bc
		ld a,b
		or c
		jr nz,.`loop

.endm




mac_memtest_announce .macro label
		; mac_con_NL
		ld hl,label
		call announcetest
.endm


; mac_memtest_announce .macro membase, memsize, memname
; 		mac_con_NL
; 		mac_con_print memname
; 		ld hl,membase
; 		ld bc,memsize
; 		call announcetest
; endm

link_memtest_block .macro membase, memsize, label
		mac_memtest_announce label
		ld e,0
		link_memtest memtestmarch, membase, memsize
.endm


link_memtest .macro proc, base, size
	.local branch
		ld iy,.`branch
		jp proc
		dw base, size
	.`branch:
.endm

link_loadregs .macro
		ld b,(iy-1)
		ld c,(iy-2)
		ld h,(iy-3)
		ld l,(iy-4)
.endm

; link_loadregs_all .macro
; 		link_loadregs
; 		ld a,(iy-5)
; endm

; mac_soundbiterr .macro bitnum
; 	.local zero,cont
; 		pause $4000

; 		bit bitnum,e
; 		jp z,.`zero

; 		music bitbadnotes
; 		jp .`cont
; 	.`zero:
; 		music bitgoodnotes
; 	.`cont:
; endm

; play_bit_errors .macro
; 	.local allbad, pbe_done
; 		ld a,$FF
; 		cp e
; 		jp z,.`allbad

; 		irpc bn,76543210
; 			mac_soundbiterr bn
; 		endm
; 		jr .`pbe_done
; 	.`allbad:
; 		music bytebadnotes
; 	.`pbe_done:
; endm

; mac_soundbiterrs .macro
; play_bit_errors .macro
; 	.local showbit, zero, msbe_cont, allbad, done
; 		ld a,$FF
; 		cp e
; 		jr z,.`allbad

; 		ld d,8
; 	.`showbit:
; 		bit 7,e
; 		jr z,.`zero
; 		ld hl,bitbadnotes
; 		jr .`msbe_cont
; 	.`zero:
; 		ld hl,bitgoodnotes
; 	.`msbe_cont:
; 		iycall playmusic
; 		pause $4000
; 		rlc e
; 		dec d
; 		jr nz,.`showbit
; 		jr .`done
; 	.`allbad:
; 		music bytebadnotes
; 	.`done:
; .endm

play_bit_errors .macro
	.local showbit, zero, msbe_cont, allbad, done
		ld a,$FF
		cp e
		jr z,.`allbad

		ld d,8
	.`showbit:
		; bit 7,e
		; jr z,.`zero
		rlc e
		jr nc,.`zero
		ld hl,bitbadnotes
		jr .`msbe_cont
	.`zero:
		ld hl,bitgoodnotes
	.`msbe_cont:
		iycall playmusic
		pause $4000
		; rlc e
		dec d
		jr nz,.`showbit
		jr .`done
	.`allbad:
		music bytebadnotes
	.`done:
.endm


mac_reportmem .macro
	.local bad, ok, cont
		jr nc,.`ok

		mac_con_print_iy biterrmsg
		iycall printbiterr_iy
		; mac_con_clear_eol_iy
		play_bit_errors
		jr .`cont
	.`ok:
		mac_con_print_iy okmsg
		; mac_con_clear_eol_iy
		music bytegoodnotes
	.`cont:
.endm

mac_reportmem_stackbank_bad .macro
		jp stackbank_bad
		; mac_con_print_iy biterrmsg
		; iycall printbiterr_iy
		; mac_con_print_iy haltmsg
		; jp drambad
.endm

mac_reportmem_stackbank_ok .macro
		mac_con_print_iy okmsg
		mac_con_print_iy msgstack
		; mac_con_clear_eol_iy
		music bytegoodnotes
.endm

mac_reportmem_stackbank .macro
	.local bad, mrs_ok
		jr nc,.`mrs_ok
		mac_reportmem_stackbank_bad
	.`mrs_ok:
		mac_reportmem_stackbank_ok
.endm



; console .macros
; global reg:
;	ix = pointer to current location in screen memory
; destroy:
;	a = working reg
;	hl = working pointer (and incoming parameter)
;	bc = counter
; preserve:
;	de
;	iy

mac_con_home .macro
		ld ix,VBASE
.endm

mac_con_clear .macro
		iycall con_clear_iy
.endm

; mac_con_clear .macro
; 	.local loop
; 		ld ix,VBASE
; 		ld bc,VSIZE
; 	.`loop:
; 		ld (ix+0),20h
; 		inc ix
; 		cpi
; 		jp pe,.`loop

; 		ld ix,VBASE
; endm

mac_con_printchar .macro ch
		ld (ix+0), '`ch`'
		inc ix
.endm

mac_con_printc .macro
		ld (ix+0), a
		inc ix
.endm

; mac_itoh_nybble_ki3v .macro
; 		or $F0
; 		daa			; is lower nybble >9? (as if doing BCD math)
; 		add a, $A0
; 		adc a, $40		; >9, so move up to 'A'
; .endm

mac_itoh_nybble .macro
		and $0F			; use just the lower bits
		cp $0A			; if over 9 set carry flag
		ccf			; invert the flag
		adc a,$30		; move into number range
		daa			; convert to decimal
.endm

mac_con_printx .macro
		ld b,a			; save a copy of the number to convert
		rra			; get upper nybble
		rra
		rra
		rra
		mac_itoh_nybble		; convert to ascii
		mac_con_printc
		ld a,b			; fetch lower nybble
		mac_itoh_nybble		; convert to ascii
		mac_con_printc		
.endm

mac_con_CR .macro
		ld a,ixl
		and $c0
		ld ixl,a
.endm

mac_con_col .macro
		ld b,0
		ld c,a
		mac_con_CR
		add ix,bc
.endm

mac_con_index .macro moveby
		ld bc,moveby
		add ix,bc
.endm

mac_con_NL .macro
	.local skip
		ld a,ixl		; go to beginning of line
		and $c0			; then go to the next line
		add a,$40
		ld ixl,a		; store the low byte back
		jr nc,.`skip
		inc ixh			; fix up high byte if there was a carry
	.`skip:
.endm

mac_con_row .macro row
		ld ix,VBASE+(row*VLINE)     ; add this offset to the base
.endm

mac_con_pos .macro row, col
		ld ix,VBASE+(row*VLINE)+col
.endm

mac_con_println .macro message
		ld hl,message
		call con_println
.endm

mac_con_print_nostack .macro message
	.local loop,done
		ld hl,message
	.`loop:
		ld a,(HL)       ; get message char
		or a            ; test for null
		jr z, .`done     ; return if done
		ld (ix+0),A     ; store char
		inc ix          ; advance screen pointer
		inc hl          ; advance message pointer
		jr .`loop        ; continue
	.`done:
.endm


mac_con_print .macro message
		ld hl,message
		; call con_print
		iycall con_print_iy
.endm

mac_con_print_iy .macro message
		ld hl,message
		iycall con_print_iy
.endm

mac_con_clear_eol_iy .macro
		iycall con_clear_eol_iy
.endm

; mac_con_clear_eol .macro
; 	.local loop
; 		ld a,ixh
; 		ld h,a
; 		ld a,ixl
; 		ld l,a
		
; 	.`loop:
; 		ld a,' '
; 		mac_con_printc
; 		ld a,ixl
; 		and $3F			; see if we are at the beginning of the line
; 		jr z,.`loop

; 		ld a,h
; 		ld ixh,a
; 		ld a,l
; 		ld ixl,a
; endm

